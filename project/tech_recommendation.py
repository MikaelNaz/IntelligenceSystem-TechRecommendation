from table_db import *


WEIGHTS = {
    "experience_level": 1.2,  # Уровень опыта чуть важнее обычных параметров
    "performance": 1.5,       # Производительность критична, повышаем вес
    "speed": 1.0,             # Скорость разработки обычная
    "cost": 0.8,              # Бюджет не самый важный параметр
    "platform": 1.7,          # Для нативных решений выбор платформы очень важен
    "community_support": 0.6  # Поддержка сообщества наименее критична
}

class TechRecommendationEngine:
    def __init__(self, conn, cursor):
        """
        Инициализирует движок рекомендаций с подключением к базе данных.
        
        Args:
            conn: Соединение с базой данных PostgreSQL
            cursor: Курсор для выполнения запросов
        """
        self.conn = conn
        self.cursor = cursor
        
        # Инициализируем таблицу технологий, если она пуста
        self._initialize_tech_database()
    
    def _initialize_tech_database(self):
        """Проверяет, есть ли записи в таблице technologies, и если нет - заполняет её начальными данными"""
        self.cursor.execute("SELECT COUNT(*) FROM technologies")
        count = self.cursor.fetchone()[0]
        
        if count == 0:
            # Начальные данные для заполнения таблицы technologies
            tech_data = [
                # Нативные решения для iOS
                ("Swift", "нативное", "ios", "средний", "критична", "средняя", "средний", 
                 "Рекомендуем Swift для нативной разработки на iOS. Высокая производительность и поддержка Apple. Компания Airbnb использовала Swift для разработки своего iOS-приложения, что позволило им добиться высокой отзывчивости интерфейса и эффективного использования системных ресурсов. Swift также обеспечивает доступ к полному набору нативных API и функций iOS, что критично для приложений с насыщенным пользовательским интерфейсом."),
                
                ("Swift/SwiftUI", "нативное", "ios", "быстрая", "новичок", "средняя", "средний", 
                 "Рекомендуем SwiftUI для быстрой разработки iOS-приложений начинающими разработчиками. Приложение Calm частично использует SwiftUI для новых модулей. SwiftUI значительно ускоряет создание современных пользовательских интерфейсов благодаря декларативному синтаксису и встроенным компонентам. Визуальный редактор позволяет увидеть изменения в реальном времени без перезапуска приложения, а система расположения элементов автоматически адаптируется к различным размерам экранов и ориентациям."),
                
                ("Swift/Objective-C", "нативное", "ios", "высокий", "критична", "средняя", "эксперт", 
                 "Рекомендуем комбинацию Swift и Objective-C для высокопроизводительных iOS-приложений. Spotify и Slack используют этот подход для своих продуктов. Для экспертов это дает возможность писать новый код на Swift, сохраняя доступ к проверенным временем библиотекам Objective-C. Такой подход обеспечивает максимальную гибкость при разработке и оптимизации критичных компонентов. При достаточном бюджете можно добиться наилучшей производительности и использовать все возможности платформы iOS."),
                
                # Нативные решения для Android
                ("Kotlin", "нативное", "android", "средний", "критична", "средняя", "средний", 
                 "Рекомендуем Kotlin для нативной разработки на Android. Опыт Pinterest показал, что переход на Kotlin значительно повысил стабильность приложения и снизил количество сбоев. Kotlin предлагает современный синтаксис, полную совместимость с Java и эффективное управление памятью, что делает его оптимальным выбором для производительных Android-приложений. Google официально поддерживает Kotlin как предпочтительный язык для Android-разработки."),
                
                ("Kotlin Native", "нативное", "android", "высокий", "критична", "средняя", "эксперт", 
                 "Рекомендуем Kotlin с Kotlin Native для высокопроизводительных Android-приложений. Яндекс использует Kotlin во многих своих мобильных приложениях. Kotlin Native позволяет компилировать код непосредственно в нативный машинный код без виртуальной машины Java, что повышает производительность критичных компонентов. Для экспертных команд с высоким бюджетом это дает возможность создавать оптимизированные приложения с потенциальным переиспользованием части логики для других платформ."),
                
                ("Jetpack Compose", "нативное", "android", "быстрая", "не критична", "средняя", "новичок", 
                 "Рекомендуем Jetpack Compose для быстрой разработки Android-приложений новичками. Google Pay и другие приложения Google постепенно переходят на Jetpack Compose. Этот современный инструментарий для создания UI с декларативным подходом значительно упрощает разработку сложных интерфейсов. Живой предпросмотр и горячая перезагрузка ускоряют итерации, а интеграция с остальными библиотеками Jetpack создает целостную экосистему для быстрой разработки качественных приложений."),
                
                # Кроссплатформенные решения
                ("Flutter", "кроссплатформенное", "любая", "новичок", "средняя", "быстрая", "низкий", 
                 "Рекомендуем Flutter для кроссплатформенной разработки. Alibaba успешно использовала Flutter для своего приложения Xianyu с аудиторией более 50 млн пользователей. Flutter предлагает богатый набор готовых виджетов, горячую перезагрузку для быстрой итерации и единую кодовую базу для iOS и Android. Dart, используемый во Flutter, имеет пологую кривую обучения, что делает его доступным для новичков при сохранении высокой скорости разработки."),
                
                ("React Native", "кроссплатформенное", "любая", "средний", "средняя", "средняя", "средний", 
                 "Рекомендуем React Native. Instagram и Walmart успешно внедрили React Native в свои мобильные приложения, достигнув баланса между производительностью и скоростью разработки. React Native использует JavaScript и реактивный подход, позволяя разработчикам применять веб-навыки в мобильной разработке. Обеспечивает доступ к нативным компонентам через мосты, что дает лучшую производительность по сравнению с полностью гибридными решениями, сохраняя при этом преимущества единой кодовой базы."),
                
                ("Flutter с нативными компонентами", "кроссплатформенное", "любая", "средний", "критична", "средняя", "средний", 
                 "Рекомендуем Flutter с дополнительными оптимизациями производительности. Alibaba's Xianyu app использует этот подход, достигая высокой производительности при кроссплатформенной разработке. Flutter уже предлагает производительность, близкую к нативной, благодаря компиляции в машинный код. Для критичных сценариев рекомендуется использовать Flutter для UI и бизнес-логики, а для особо требовательных компонентов создавать платформенные каналы к нативному коду. Такой подход обеспечивает хороший баланс между затратами на разработку и итоговой производительностью."),
                
                ("NativeScript", "кроссплатформенное", "любая", "эксперт", "критична", "средняя", "высокий", 
                 "Рекомендуем NativeScript для критичных по производительности кроссплатформенных приложений. Raiffeisen Bank использовал NativeScript для своего мобильного банкинга, получив близкую к нативной производительность. NativeScript обеспечивает прямой доступ к нативным API без JavaScript-мостов, что значительно повышает скорость работы. Для опытных разработчиков NativeScript предлагает мощные инструменты оптимизации и профилирования, а также возможность напрямую использовать нативные библиотеки."),
                
                # Гибридные решения
                ("Ionic", "гибридное", "любая", "новичок", "не критична", "средняя", "низкий", 
                 "Рекомендуем Ionic. MarketWatch и Sworkit используют Ionic для своих приложений благодаря его интеграции с Angular, Vue или React. Ionic предлагает широкую библиотеку компонентов пользовательского интерфейса, которые автоматически адаптируются под iOS и Android. Это значительно сокращает время и стоимость разработки, а поддержка веб-технологий (HTML, CSS, JavaScript) делает его доступным для веб-разработчиков без опыта мобильной разработки."),
                
                ("Progressive Web App", "гибридное", "любая", "новичок", "не критична", "быстрая", "низкий", 
                 "Рекомендуем Progressive Web App (PWA) для гибридной разработки. Twitter Lite и Starbucks успешно внедрили PWA, что привело к увеличению вовлеченности пользователей и снижению затрат на разработку. PWA работают в браузере, но предлагают функции, близкие к нативным приложениям, включая офлайн-режим, push-уведомления и доступ к некоторым API устройства. Минимальные требования к установке и автоматические обновления делают PWA идеальным решением для стартапов с ограниченным бюджетом."),
                
                ("Quasar Framework", "гибридное", "любая", "средний", "не критична", "быстрая", "средний", 
                 "Рекомендуем Quasar Framework для гибридных приложений с высокой скоростью разработки. Компания CleverTech использовала Quasar для быстрой разработки корпоративных приложений. Quasar основан на Vue.js и предлагает единую кодовую базу для веб, мобильных и десктопных приложений. Отличается богатой экосистемой готовых компонентов и интеграций, что значительно ускоряет процесс разработки при сохранении качества интерфейса."),
                
                ("Ionic с Capacitor", "гибридное", "любая", "средний", "средняя", "средняя", "средний", 
                 "Рекомендуем Ionic с Capacitor для гибридной разработки. Компания Dow Jones использовала эту комбинацию для своего приложения MarketWatch. Ionic предоставляет богатую библиотеку UI-компонентов и интеграцию с популярными JavaScript-фреймворками, а Capacitor обеспечивает доступ к нативным API устройства. Это сочетание позволяет сократить время и стоимость разработки при сохранении доступа к нативной функциональности. Преимущество этого подхода в единой кодовой базе и возможности использования веб-навыков команды.")
            ]
            
            for tech in tech_data:
                self.cursor.execute("""
                    INSERT INTO technologies (name, type, platform, experience_level, performance, speed, cost, recommendation_text)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                """, tech)
            
            self.conn.commit()

    def normalize_answer(self, key, value):
        """Нормализует значения для всех категорий ответов"""
        mappings = {
            "type": {
                "нативное": "нативное",
                "айфон": "нативное",
                "натив": "нативное",
                "родное": "нативное",
                "кроссплатформенное": "кроссплатформенное",
                "кроссплатформа": "кроссплатформенное",
                "кросс-платформа": "кроссплатформенное",
                "гибридное": "гибридное",
                "гибрид": "гибридное",
                "гибридный": "гибридное"
            },
            "platform": {
                "ios": "ios",
                "айос": "ios",
                "apple": "ios",
                "айфон": "ios",
                "android": "android",
                "андроид": "android",
                "google": "android"
            },
            "experience_level": {
                "новички": "новичок",
                "новичок": "новичок",
                "начинающий": "новичок",
                "junior": "новичок",
                "средние": "средний",
                "средний": "средний",
                "мидл": "средний",
                "middle": "средний",
                "эксперты": "эксперт",
                "эксперт": "эксперт",
                "senior": "эксперт",
                "профи": "эксперт"
            },
            "performance": {
                "критична": "критична",
                "важна": "критична",
                "высокая": "критична",
                "приоритет": "критична",
                "средняя": "средняя",
                "умеренная": "средняя",
                "некритична": "не критична",
                "неважна": "не критична",
                "низкая": "не критична",
                "некритичный" : "не критична"
            },
            "speed": {
                "быстрая": "быстрая",
                "скорость": "быстрая",
                "срочно": "быстрая",
                "fast": "быстрая",
                "средняя": "средняя",
                "умеренная": "средняя",
                "medium": "средняя",
                "низкая": "низкая",
                "медленная": "низкая",
                "длительная": "низкая",
                "slow": "низкая",
                "длительная": "низкая",
                "длительна": "низкая"
            },
            "cost": {
                "низкий": "низкий",
                "дешево": "низкий",
                "эконом": "низкий",
                "low": "низкий",
                "средний": "средний",
                "medium": "средний",
                "обычный": "средний",
                "высокий": "высокий",
                "дорого": "высокий",
                "премиум": "высокий",
                "high": "высокий"
            },
            "community_support": {
                "сильное": "сильное",
                "активное": "сильное",
                "хорошее": "сильное",
                "strong": "сильное",
                "среднее": "среднее",
                "умеренное": "среднее",
                "medium": "среднее",
                "слабое": "слабое",
                "плохое": "слабое",
                "weak": "слабое"
            }
        }
        
        # Приводим значение к нижнему регистру перед проверкой
        value = value.lower().strip() if isinstance(value, str) else str(value).lower()
        
        # Специальная обработка для числовых значений бюджета
        if key == "cost" and value.isdigit():
            value = int(value)
            if value < 1000: return "низкий"
            elif 1000 <= value < 5000: return "средний"
            else: return "высокий"
        
        return mappings.get(key, {}).get(value, value)
    
    def get_recommendation(self, answers):
        """
        Гибкий алгоритм подбора рекомендации из БД.
        Для каждой технологии сравниваем параметры с ответами пользователя и суммируем совпадения.
        """        
        if "start" in answers:
            answers["type"] = answers.pop("start")

        print(f"DEBUG: Входные данные: {answers}")

        # Нормализуем ответы пользователя
        normalized = {}
        for key in ["type", "platform", "experience_level", "performance", "cost", "speed", "community_support"]:
            if key in answers and answers[key]:
                normalized[key] = self.normalize_answer(key, answers[key].lower().strip())
        
        print(f"DEBUG: Нормализованные ответы: {normalized}")
        
        # Определяем, какие параметры указаны пользователем
        parameters = ["experience_level", "performance", "cost", "speed", "platform", "community_support"]
        
        # Фильтруем технологии по типу приложения
        user_type = normalized.get("type")
        
        # Получаем все технологии из БД по указанному типу
        cursor.execute("""
            SELECT id, name, platform, experience_level, performance, cost, speed, recommendation_text 
            FROM technologies 
            WHERE type = %s
        """, (user_type,))
        technologies = cursor.fetchall()
        
        best_score = -1
        best_recommendation = None
        
        # Для каждой технологии считаем, сколько параметров совпадает
        for tech in technologies:
            tech_id, name, platform, exp_level, performance, cost, speed, recommendation = tech
            
            # Создаем словарь с параметрами технологии
            tech_params = {
                "platform": platform.lower() if platform else "",
                "experience_level": exp_level.lower() if exp_level else "",
                "performance": performance.lower() if performance else "",
                "cost": cost.lower() if cost else "",
                "speed": speed.lower() if speed else ""
            }
            
            score = 0
            total = 0
            
            # Проходим по параметрам, которые указал пользователь
            for param in parameters:
                if param in normalized and param in tech_params:
                    # Для нативных решений параметр platform должен учитываться отдельно
                    if param == "platform" and user_type != "нативное":
                        continue
                        
                    total += 1
                    if normalized[param] == tech_params[param]:
                        score += 1  # Совпадение параметра
                        score += WEIGHTS.get(param, 1.0)  # Добавляем вес параметра
            
            # Учитываем фидбэк от пользователей
            cursor.execute("SELECT SUM(rating) FROM feedback WHERE technology_id = %s", (tech_id,))
            feedback_result = cursor.fetchone()
            feedback_score = feedback_result[0] if feedback_result and feedback_result[0] is not None else 0
            score += feedback_score * 0.5  # Добавляем вес фидбэка
            
            # Вычисляем долю совпадений для этой технологии
            ratio = score / total if total > 0 else 0
            
            print(f"DEBUG: Технология {name}, оценка {score}, доля {ratio}")
            
            # Если совпадений больше предыдущего и доля больше минимального порога, обновляем лучший выбор
            if ratio >= 0.5 and score > best_score:
                best_score = score
                best_recommendation = recommendation

        if best_recommendation:
            return best_recommendation

        return ("На основе ваших ответов сложно дать однозначную рекомендацию. "
                "Рассмотрите возможность консультации с экспертом по мобильной разработке "
                "для более детального анализа вашего проекта.")